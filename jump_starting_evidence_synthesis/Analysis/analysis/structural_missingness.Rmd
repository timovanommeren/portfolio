---
title: "structual_missingness"
output: html_document
date: "2025-11-24"
---

```{r}
library(here)

source(here("Analysis/R/00_packages.R"))
source(here("Analysis/R/01_load_data.R"))
source(here("Analysis/R/02_prepare_data.R"))
source(here("Analysis/R/03_descriptives.R"))
# source(here("R/04_models.R"))
# source(here("R/05_plots.R"))

load_packages()

```

## Loading and transforming data

```{r load and transform data}

# import simulation results and metadata (specify paths relative to project root)
raw <- load_simulation_data(data = "simulation_results/adding_NAs/all_simulation_results.csv", 
                             metadata = "Analysis/percentage_relevant.csv")

# (1) transform simulation data to wide
# (2) adjust metadata column names, and, 
# (3) add the number of records and percent_rel of relevant records from metadata to simulation data (these will serve as group-level predictors in multilevel model)
processed <- prepare_data(raw$simulation, raw$meta)

# assign to variables for easier access
simulation_long <- raw$simulation
simulation      <- processed$simulation
metadata        <- processed$meta

```


```{r}

#plot a histogram of n_abstracts
ggplot(simulation, aes(x = n_abstracts)) +
  geom_histogram(binwidth = 1, fill = "lightblue", color = "black") +
  labs(title = "Histogram of n_abstracts",
       x = "Number of Abstracts",
       y = "Frequency") +
  theme_minimal()


#plot the distribution of td against the IV: n_abstracts
# Note that n_abstracts has 5 imposed categories and no measurement error. So we should use jitter to better visualize the data points.

ggplot(simulation, aes(x = n_abstracts, y = td)) +
  geom_jitter(width = 0.2, height = 0, alpha = 0.5) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  labs(title = "Distribution of td against n_abstracts",
       x = "Number of Abstracts",
       y = "td") +
  theme_minimal()

correlation_n_abstracts_td <- cor(simulation$n_abstracts, simulation$td, use = "complete.obs")
correlation_n_abstracts_td
```

```{r}

#make dummy variable of n_abstracts, which is 0 below median and 1 above median
median_n_abstracts <- median(simulation$n_abstracts, na.rm = TRUE)

simulation <- simulation %>%
  mutate(
    n_abstracts_dummy = ifelse(n_abstracts <= median_n_abstracts, 0, 1)
  )

#impute all NAs in n_abstracts_dummy with 0
simulation$n_abstracts_dummy[is.na(simulation$n_abstracts_dummy)] <- 0

#plot a histogram of n_abstracts_dummy
hist(simulation$n_abstracts_dummy, 
     main = "Histogram of n_abstracts_dummy", 
     xlab = "n_abstracts_dummy", 
     col = "lightgreen", 
     border = "black")

# renamee n_abstracts_dummy to n_abstracts_above_median
simulation <- simulation %>%
  rename(llm_condition_abstract_high = n_abstracts_dummy)

#create a new dummy llm_condition_abstract_low by taking the difference between llm = 1 and llm_condition_abstract_high

simulation$llm_condition_abstract_low = simulation$condition_llm - simulation$llm_condition_abstract_high

```

```{r}

#create three new dummy variables, each corresponding to one of the three conditions
simulation <- simulation %>%
  mutate(
    condition_llm = ifelse(condition == "llm", 1, 0),
    condition_random = ifelse(condition == "random", 1, 0),
    condition_no_initialisation = ifelse(condition == "no_initialisation", 1, 0)
  )

#reorder the columns to have the conditions first
simulation <- simulation %>%
  select(dataset, condition_llm, condition_random, condition_no_initialisation, llm_condition_abstract_high, llm_condition_abstract_low, everything())

```

```{r}

dummy_model <- lm(td ~ condition_random + condition_no_initialisation + dataset, data = simulation)

summary(dummy_model)

```


### Testing how relevel works

```{r}

hist(simulation$n_abstracts)

#run basic linear model
model_test <- lm(td ~ condition * n_abstracts + dataset, data = simulation)



summary(model_test)
head(model.matrix(model_test))


# Check  the  design  matrix  by  computing  the  crossproduct
crossprod(model.matrix(model_test))
```


```{r}

#set conditions as factor 
simulation$condition <- as.factor(simulation$condition)

# relevel condition to set "random" as the reference level
simulation$condition <- relevel(simulation$condition, ref = "llm")

#run basic linear model
model_test <- lm(td ~ condition, data = simulation)
summary(model_test)
head(model.matrix(model_test))
```



### Recoding and centering LLM parameters to account for the fact that the first level IVs are only defined in the llm condition

```{r}

simulation <- simulation %>%
  mutate(
    
    # indicator where llm parameters are actually defined
    llm_active = (condition == "llm"),

    # center within llm, set to 0 elsewhere (two-part coding)
    n_abstracts_llm = ifelse(
      llm_active,
      n_abstracts - mean(n_abstracts[llm_active], na.rm = TRUE),
      0
    ),
    length_abstracts_llm = ifelse(
      llm_active,
      length_abstracts - mean(length_abstracts[llm_active], na.rm = TRUE),
      0
    ),
    llm_temperature_llm = ifelse(
      llm_active,
      llm_temperature - mean(llm_temperature[llm_active], na.rm = TRUE),
      0
    )
  )

```



#### Data visualisation

Let's plot the recoded data to illustrate that the centered variables are only defined in the llm condition.
```{r}
ggplot(simulation, aes(x = n_abstracts_llm, y = td, color = condition)) +
  geom_point(alpha = 0.5) +
  labs(title = "Recoded n_abstracts_llm vs td",
       x = "Recoded n_abstracts_llm",
       y = "td") +
  theme_minimal()

```

### LLM-condition specific variables



```{r}
model0 <- lmer(td ~ 1 + (1|dataset), REML = F, data = simulation)
summary(model0)
```

```{r}
model1 <- lmer(td ~ condition + (1|dataset), REML = F, data = simulation)
summary(model1)

anova(model1, model0)


summary(lm(td ~ condition + dataset, data = simulation))

# model.matrix(model1)
# lme4::getME(model1, "X")
# 
# ?lme4::getME()
# lme4::getME(model1, "Z")
# 
# ?show()
```



```{r}

#simulation_llm <- simulation %>% filter(condition == "llm")

model2a <- lmer(
  td ~ condition +
       n_abstracts_llm + length_abstracts_llm + llm_temperature_llm +
       (1 | dataset),
  REML = FALSE,
  data = simulation
)

summary(model2a)
anova(model2a, model1)
```



```{r}

# model2b <- lmer(
#   td ~ condition + 
#        condition * (n_abstracts_llm + length_abstracts_llm + llm_temperature_llm) +
#        (1 | dataset),
#   REML = FALSE,
#   data = simulation
# )
# 
# summary(model2b)
# anova(model2b, model2a)
```



```{r}

model3 <- lmer(
  td ~ condition +
       n_abstracts_llm + length_abstracts_llm + llm_temperature_llm +
       records + 
       (1 | dataset),
  REML = FALSE,
  data = simulation
)

summary(model3)
anova(model3, model2a)

```
```{r}
model4 <- lmer(
  td ~ condition +
       n_abstracts_llm + length_abstracts_llm + llm_temperature_llm +
       (condition | dataset),
  REML = FALSE,
  data = simulation
)

summary(model4)
anova(model3, model2a)

```




Let's see if the method proposed by Dzaik and applied above is valid by seeing if we get the same regression coefficients when we split the data and run the model only on the llm condition and on the two remaining conditions separately.

```{r}
simulation_llm <- simulation %>% filter(condition == "llm")

model_llm_only <- lmer(
  td ~ 
       n_abstracts + length_abstracts + llm_temperature +
       (1 | dataset),
  REML = FALSE,
  data = simulation_llm
)

```

```{r}
simulation_random <- simulation %>% filter(condition == "random")

simulation_random <- lmer(
  td ~ 
       (1 | dataset),
  REML = FALSE,
  data = simulation_random
)

```

```{r}
simulation_no_init <- simulation %>% filter(condition == "no_initialisation")

simulation_no_init <- lmer(
  td ~ 
       (1 | dataset),
  REML = FALSE,
  data = simulation_no_init
)

```


```{r}

fixef(model_llm_only)["(Intercept)"] - fixef(simulation_random)["(Intercept)"]; fixef(model3)["conditionrandom"]

fixef(simulation_no_init)["(Intercept)"] - fixef(model_llm_only)["(Intercept)"];
fixef(model3)["conditionno_initialisation"]

```





## Comparing to separate linear models (no random effects)



```{r}

#remove rows with dataset == 'Walker_2018'
simulation <- simulation %>%
  filter(dataset != "Walker_2018")

#set condition as factor
simulation$condition <- as.factor(simulation$condition)

#set 'random' as the reference level
simulation$condition <- relevel(simulation$condition, ref = "random")

#create new variables for interaction terms
simulation <- simulation %>%
  mutate(
    condition_llm_percent_rel = condition_llm * percent_rel
  )

# 1) Big two-part model (no random effects)
lm_big <- lm(
  td ~ condition +
       n_abstracts_llm + length_abstracts_llm + llm_temperature_llm +
      condition_llm_percent_rel +
      dataset
    ,
  data = simulation
)

summary(lm_big)

model.matrix(lm_big)
```



```{r}
# 2) Separate models
lm_llm <- lm(
  td ~ n_abstracts + length_abstracts + llm_temperature,
  data = subset(simulation, condition == "llm")
)

lm_random <- lm(
  td ~ 1,
  data = subset(simulation, condition == "random")
)

lm_noinit <- lm(
  td ~ 1,
  data = subset(simulation, condition == "no_initialisation")
)

```


```{r}
# Compare fitted values
coef(lm_big)["(Intercept)"] + coef(lm_big)["conditionrandom"]; coef(lm_random)["(Intercept)"]
coef(lm_big)["(Intercept)"] + coef(lm_big)["conditionno_initialisation"]; coef(lm_noinit)["(Intercept)"]

```


